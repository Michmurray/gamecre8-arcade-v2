// scripts/build-manifest.mjs
// Unified "drop anywhere" builder. Drag all images into assets/library (or keep
// using assets/backgrounds and assets/sprites). We auto-classify and add tags.
// No renaming required.

import { promises as fs } from "fs";
import path from "path";

const ROOT = process.cwd();
const ASSETS = path.join(ROOT, "assets");
const LIB = path.join(ASSETS, "library");
const BG_DIR = path.join(ASSETS, "backgrounds");   // still supported
const SPR_DIR = path.join(ASSETS, "sprites");       // still supported
const OUT = path.join(ASSETS, "manifest.json");
const EXTS = new Set([".png", ".jpg", ".jpeg", ".webp"]);
const IGNORE = new Set(["bg","background","sprite","tilesheet","sheet","image","img","player","character","color","colour"]);

function pj(...p){ return path.join(...p).replace(/\\/g,"/"); }
async function ensureDir(d){ await fs.mkdir(d,{recursive:true}); }

function tagsFromName(base){
  const noExt = base.replace(/\.[^.]+$/, "");
  const split = noExt.replace(/([a-z])([A-Z])/g, "$1 $2").toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
  return split.filter(w => !IGNORE.has(w));
}

async function listFiles(dir){
  try{
    const ents = await fs.readdir(dir, {withFileTypes:true});
    const files=[];
    for(const e of ents){
      if(e.isFile()){
        const ext = path.extname(e.name).toLowerCase();
        if(EXTS.has(ext)) files.push(pj(dir, e.name));
      }
    }
    return files;
  }catch{return []}
}

// --- quick width/height sniffers (PNG/JPEG) to help classification ---
async function readSize(p){
  try{
    const buf = await fs.readFile(p);
    const ext = path.extname(p).toLowerCase();
    if (ext === ".png") {
      // PNG: IHDR at 16..24, big-endian
      const w = buf.readUInt32BE(16), h = buf.readUInt32BE(20);
      return {w, h};
    }
    if (ext === ".jpg" || ext === ".jpeg") {
      // JPEG: scan segments until SOF0/SOF2
      let i = 2;
      while (i < buf.length) {
        if (buf[i] !== 0xFF) break;
        const marker = buf[i+1];
        const len = buf.readUInt16BE(i+2);
        if (marker === 0xC0 || marker === 0xC2) {
          const h = buf.readUInt16BE(i+5);
          const w = buf.readUInt16BE(i+7);
          return {w, h};
        }
        i += 2 + len;
      }
    }
  }catch{}
  return null;
}

function looksLikeSpriteName(base){
  return /(sprite|tilesheet|sheet|player|character|soldier|zombie)/i.test(base);
}
function looksLikeBackgroundName(base){
  return /(bg|background|castle|forest|grass|desert|mountain|ocean|water|underwater|city|urban|snow|winter)/i.test(base);
}

function detectGridBySize(size){
  if(!size) return null;
  const W=size.w, H=size.h;
  const candidates = [
    [12,1],[10,1],[8,1],[6,1],[5,1],[4,1],[3,1],[2,1],
    [1,12],[1,10],[1,8],[1,6],[1,5],[1,4],[1,3],[1,2],
    [4,2],[3,2],[2,3],[4,4]
  ];
  for(const [cols,rows] of candidates){
    if((W % cols) === 0 && (H % rows) === 0){
      // prefer a grid with cols>1
      return {cols, rows};
    }
  }
  return null;
}

function classify(base, size){
  // filename hints first
  if (looksLikeBackgroundName(base)) return "backgrounds";
  if (looksLikeSpriteName(base)) return "players";
  // size-based fallback
  if (size){
    const maxSide = Math.max(size.w, size.h);
    const area = size.w * size.h;
    // large scenic images → backgrounds
    if (maxSide >= 900 || area >= 900*700) return "backgrounds";
    // smaller sheets/icons → players
    if (maxSide <= 800) return "players";
  }
  // default to players if ambiguous (better to render a character than a bg)
  return "players";
}

async function gather(){
  await ensureDir(ASSETS);
  await ensureDir(LIB);        // drop-zone
  await ensureDir(BG_DIR);     // still honored
  await ensureDir(SPR_DIR);    // still honored

  const files = [
    ...(await listFiles(LIB)),
    ...(await listFiles(BG_DIR)),
    ...(await listFiles(SPR_DIR)),
  ];

  const backgrounds=[], players=[];
  for(const full of files){
    const rel = "/" + path.relative(ROOT, full).replace(/\\/g,"/");
    const base = path.basename(full);

    const size = await readSize(full);  // may be null for some formats
    const kind = classify(base, size);
    const t = tagsFromName(base);

    if (kind === "backgrounds") {
      backgrounds.push({ id: base.replace(/\.[^.]+$/,""), path: rel, tags: t });
    } else {
      const grid = detectGridBySize(size);
      const item = { id: base.replace(/\.[^.]+$/,""), path: rel, tags: t };
      if (grid) item.frame = grid; // helps runtime, still optional
      players.push(item);
    }
  }

  // deterministic order
  backgrounds.sort((a,b)=> a.id.localeCompare(b.id));
  players.sort((a,b)=> a.id.localeCompare(b.id));

  const manifest = { backgrounds, players, hazards: [], coins: [] };
  await fs.writeFile(OUT, JSON.stringify(manifest, null, 2) + "\n");
  console.log("Wrote", OUT, `(bg:${backgrounds.length}, players:${players.length})`);
}

gather().catch(err => { console.error(err); process.exit(1); });
